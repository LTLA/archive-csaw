
R version 3.1.0 (2014-04-10) -- "Spring Dance"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ###################################################################################################
> # This script tests the PET-analysis capabilities of the 'csaw' package.
> 
> suppressPackageStartupMessages(library(csaw))
> 
> source("simsam.R")
> dir<-"pet-test"
> dir.create(dir)
> 
> compstat<-function (nreads, singles, chromosomes) {
+     # Seeding all reads.
+ 	names<-paste('x', rep(1:nreads, 2), sep=".");
+ 	chrs<-sample(length(chromosomes), length(names), replace=TRUE)
+ 	pos<-rep(0, length(names));
+ 
+ 	# Assigning positions to all of them.
+ 	for (i in 1:length(chromosomes)) {
+ 		current<-chrs==i;
+ 		pos[current]<-round(runif(sum(current), 1, chromosomes[i]))
+ 	}
+ 
+     # Throwing them into the SAM file generator. 
+ 	str<-rbinom(nreads*2, 1, 0.5)==1; 
+ 	outname<-file.path(dir, "out")
+ 	rlen<-10;
+ 	reversi<-c(nreads+1:nreads, 1:nreads)
+ 	out<-simsam(outname, names(chromosomes)[chrs], pos, str, chromosomes, names=names, len=rlen,
+ 			is.paired=TRUE, is.first=c(rep(TRUE, nreads), rep(FALSE, nreads)), 
+ 			mate.chr=names(chromosomes)[chrs][reversi], mate.pos=pos[reversi], mate.str=str[reversi])
+ 
+ 	# Adding some singles.
+ 	if (singles) {
+ 		snames<-paste('y', 1:singles, sep=".");
+ 		schrs<-sample(length(chromosomes), singles, replace=TRUE)
+ 		spos<-rep(0, singles);
+ 		for (i in 1:length(chromosomes)) {
+ 			scurrent<-schrs==i;
+ 			spos[scurrent]<-round(runif(sum(scurrent), 1, chromosomes[i]))
+ 		}
+ 		sstr<-rnbinom(singles, 1, 0.5)==1
+ 
+ 		tempname<-file.path(dir, "temp")
+ 		out2<-simsam(tempname, names(chromosomes)[schrs], spos, sstr, chromosomes, names=snames, len=rlen)
+ 		more.temp<-file.path(dir, "temp2")
+ 		out<-mergeBam(c(out, out2), more.temp, indexDestination=TRUE, overwrite=TRUE)
+ 		file.rename(more.temp, out)
+ 	}
+ 
+ 	stuff<-getPETSizes(out);
+ 	if (stuff$diagnostics[["single"]]!=singles) { 
+ 		stop("mismatch in number of singles");
+ 	} else if (stuff$diagnostics[["total"]]!=nreads*2+singles) {
+ 		stop("mismatch in total number of reads");
+ 	} 
+ 
+     # Checking whether the sizes make sense.
+ 	pos1<-pos[1:nreads]
+ 	pos2<-pos[nreads+1:nreads]
+ 	chr1<-chrs[1:nreads]
+ 	chr2<-chrs[nreads+1:nreads]
+ 	str1<-str[1:nreads]
+ 	str2<-str[nreads+1:nreads]
+ 	valid<-(chr1==chr2 & str1!=str2 & ifelse(str1, pos1 <= pos2, pos2 <= pos1))
+ 
+ 	print(stuff$diagnostics)	
+ 	if (sum(chr1!=chr2)!=stuff$diagnostics[["inter.chr"]]) { stop("mismatch in interchromosomal PETs"); }
+     
+    	pos1[!str1]<-pmin(pos1[!str1]+rlen, chromosomes[chr1][!str1]+1)
+ 	pos2[!str2]<-pmin(pos2[!str2]+rlen, chromosomes[chr2][!str2]+1)
+    	sizes<-abs(pos1-pos2)[valid]
+ 	stopifnot(length(sizes)==length(stuff$sizes));
+ 	if (any(sort(sizes)!=sort(stuff$sizes))) { stop("mismatch in sizes"); }
+ 
+ 	# Checking incorrect orientations.
+ 	invalid <- chr1==chr2 & !valid
+ 	if (sum(invalid)!=stuff$diagnostics[["unoriented"]]) { stop("mismatch in invalid numbers") }
+ 
+ 	# Checking what happens when you max out the MAPQ.
+ 	stuff <- getPETSizes(out, minq=500)
+ 	if (length(stuff$sizes) || any(stuff$diagnostics!=0L)) { 
+ 		stop("mismatch in unmapping numbers when MAPQ is set high")
+ 	}
+ 
+ 	# Checking what happens when you drop everything on not on the first chromosome (ensure 'unmapped' is correct)
+ 	if (length(chromosomes) > 1L) { 
+ 		chosen <- 1
+ 		stuff <- getPETSizes(out, restrict=names(chromosomes)[chosen])
+ 		obs.total <- sum(chr1==chosen) + sum(chr2==chosen) 
+ 		if (singles) { obs.total <- obs.total + sum(schrs==chosen) }
+ 		if (obs.total != stuff$diagnostics[["total"]]) { stop("mismatch in total numbers upon restriction") }
+ 		if (sum(chr1==chosen & chr2!=chosen) + sum(chr2==chosen & chr1!=chosen) != stuff$diagnostics[["mate.unmapped"]]) {
+ 			stop("mismatch in unmapped numbers upon restriction") }
+ 	}
+ 	
+ 	head(sizes);
+ }
> 
> # Now running through a gamut of tests.
> 
> set.seed(1002)
> 
> compstat(500, 0, c(chrA=1000, chrB=2000))
        total        single    unoriented mate.unmapped     inter.chr 
         1000             0           176             0           259 
[1] 746 475 617 786 987 681
> 
> compstat(1000, 0, c(chrA=1000, chrB=2000))
        total        single    unoriented mate.unmapped     inter.chr 
         2000             0           367             0           496 
[1]  416  857  168 1252 1022  205
> 
> compstat(2000, 0, c(chrA=1000, chrB=2000))
        total        single    unoriented mate.unmapped     inter.chr 
         4000             0           779             0           947 
[1]  310  313 1207  357 1362  576
> 
> compstat(5000, 0, c(chrA=1000, chrB=2000))
        total        single    unoriented mate.unmapped     inter.chr 
        10000             0          1882             0          2507 
[1] 209  18  23 484 815  64
> 
> # Again, with some singles.
> 
> compstat(500, 20, c(chrA=1000, chrB=2000))
        total        single    unoriented mate.unmapped     inter.chr 
         1020            20           178             0           262 
[1]  684  202  266   62  312 1161
> 
> compstat(1000, 100, c(chrA=1000, chrB=2000))
        total        single    unoriented mate.unmapped     inter.chr 
         2100           100           383             0           500 
[1] 1431  166   99  619  730  210
> 
> compstat(2000, 100, c(chrA=1000, chrB=2000))
        total        single    unoriented mate.unmapped     inter.chr 
         4100           100           732             0          1012 
[1]  670  558 1329  482  352  512
> 
> compstat(5000, 100, c(chrA=1000, chrB=2000))
        total        single    unoriented mate.unmapped     inter.chr 
        10100           100          1845             0          2551 
[1] 308 356 524 599 593 221
> 
> # Going pathologically low to force the PET algorithm to process end-of-chromosome catches and stacked F/R reads.
> 	
> compstat(1000, 0, c(chrA=50))
        total        single    unoriented mate.unmapped     inter.chr 
         2000             0           745             0             0 
[1] 38 32 24  7 17 25
> 
> compstat(1000, 0, c(chrA=10))
        total        single    unoriented mate.unmapped     inter.chr 
         2000             0           730             0             0 
[1] 7 4 2 9 7 9
> 
> compstat(2000, 0, c(chrA=10))
        total        single    unoriented mate.unmapped     inter.chr 
         4000             0          1455             0             0 
[1] 5 6 5 9 8 9
> 
> compstat(5000, 0, c(chrA=10))
        total        single    unoriented mate.unmapped     inter.chr 
        10000             0          3658             0             0 
[1] 5 6 6 6 8 8
> 
> ###################################################################################################
> # We then write a function to check the extraction procedure.	
> 	
> checkcount<-function (nreads, chromosomes, spacing=50, max.frag=500, left=0, right=0, filter=-1, ext=100) {
+ 	stuff<-file.path(dir, paste("x", 1:2, sep=""));
+ 	all.ranges<-list()
+ 	first.is.left <- list()
+ 
+ 	for (x in 1:length(stuff)) {
+     	# Seeding all reads.
+ 		names<-paste('x', rep(1:nreads, 2), sep=".");
+ 		chrs<-sample(length(chromosomes), length(names), replace=TRUE)
+ 		pos<-rep(0, length(names));
+ 
+ 		# Assigning positions to all of them.
+ 		for (i in 1:length(chromosomes)) {
+ 			current<-chrs==i;
+ 			pos[current]<-round(runif(sum(current), 1, chromosomes[i]))
+ 		}
+ 
+     	# Throwing them into the SAM file generator. 
+ 		str<-rbinom(length(names), 1, 0.5)==1; 
+ 		rlen<-10;
+ 		reversi<-c(1:nreads+nreads, 1:nreads)
+ 		out<-simsam(stuff[x], names(chromosomes)[chrs], pos, str, chromosomes, names, 
+ 				is.first=c(rep(TRUE, nreads), rep(FALSE, nreads)), is.paired=TRUE, 
+ 				mate.chr=names(chromosomes)[chrs][reversi], mate.pos=pos[reversi], 
+ 				mate.str=str[reversi], len=rlen);
+ 
+     	# Extracting all valid hits.
+ 		pos1<-pos[1:nreads]
+ 		pos2<-pos[nreads+1:nreads]
+ 		chr1<-chrs[1:nreads]
+ 		chr2<-chrs[nreads+1:nreads]
+ 		str1<-str[1:nreads]
+ 		str2<-str[nreads+1:nreads]
+ 		valid<-(chr1==chr2 & str1!=str2 & ifelse(str1, pos1 <= pos2, pos2 <= pos1))
+     	
+    		pos1[!str1]<-pmin(pos1[!str1]+rlen, chromosomes[chr1][!str1]+1)
+ 		pos2[!str2]<-pmin(pos2[!str2]+rlen, chromosomes[chr2][!str2]+1)
+    		sizes<-abs(pos1-pos2)[valid]
+ 		vpos<-ifelse(str1, pos1, pos2)[valid]
+ 		vchrs<-chr1[valid]
+ 	
+ 		# Filtering by the maximum size.	
+ 		is.spaced<-sizes>max.frag;
+ 		sizes<-sizes[!is.spaced];
+ 		vpos<-vpos[!is.spaced];
+ 	 	vchrs<-vchrs[!is.spaced];
+ 
+     	# Compiling them into counts for each chromosome.
+ 		all.ranges[[x]]<-GRanges(names(chromosomes)[vchrs], IRanges(vpos, vpos+sizes-1))
+ 		first.is.left[[x]] <- str1[valid][!is.spaced]
+ 	}
+ 
+     # Collating all counts.
+ 	fnames <- paste0(stuff, ".bam")
+ 	x<-windowCounts(fnames, spacing=spacing, max.frag=max.frag, shift=left, width=right+left+1, pet="both", filter=filter)
+ 	out<-matrix(0L, length(x$region), length(stuff))
+ 	totals<-integer(length(stuff))
+ 	for (i in 1:length(stuff)) {
+         current<-findOverlaps(x$region, all.ranges[[i]])
+         out[,i]<-tabulate(queryHits(current), nbins=length(x$region))
+ 		totals[i]<-length(all.ranges[[i]])
+ 	}
+ 
+ 	if (!identical(out, x$counts)) { stop('mismatches in counts for paired data') }
+ 	if (!identical(totals, x$totals)) { stop("mismatches in totals for paired data") }
+ 
+ 	# Also checking forward and reverse counts.
+ 	for (mode in c("first", "second")) { 
+ 		bravo <- windowCounts(fnames, spacing=spacing, ext=ext, shift=left, width=right+left+1, pet=mode, filter=filter)
+ 		out<-matrix(0L, length(x$region), length(stuff))
+ 		totals<-integer(length(stuff))
+ 		for (i in 1:length(stuff)) {
+ 			cur.ranges <- all.ranges[[i]]
+ 			if (mode=="first") {
+ 				cur.stat <- first.is.left[[i]]
+ 			} else {
+ 				cur.stat <- !first.is.left[[i]]
+ 			}
+ 			start(cur.ranges) <- ifelse(cur.stat, start(cur.ranges), end(cur.ranges)-ext+1L)
+ 			end(cur.ranges) <- ifelse(cur.stat, start(cur.ranges)+ext-1L, end(cur.ranges))
+         	current<-findOverlaps(x$region, all.ranges[[i]])
+        		out[,i]<-tabulate(queryHits(current), nbins=length(x$region))
+ 			totals[i]<-length(all.ranges[[i]])
+ 		}
+ 		if (!identical(out, x$counts)) { stop('mismatches in counts for single coercion') }
+ 		if (!identical(totals, x$totals)) { stop("mismatches in totals for single coercion") }
+ 	}
+ 		
+ 
+ 	return(x$region)
+ }
> 
> # Running through a bunch of tests.
> 
> checkcount(1000, c(chrA=1000, chrB=2000), spacing=20)
GRanges with 150 ranges and 0 metadata columns:
        seqnames       ranges strand
           <Rle>    <IRanges>  <Rle>
    [1]     chrA     [ 1,  1]      *
    [2]     chrA     [21, 21]      *
    [3]     chrA     [41, 41]      *
    [4]     chrA     [61, 61]      *
    [5]     chrA     [81, 81]      *
    ...      ...          ...    ...
  [146]     chrB [1901, 1901]      *
  [147]     chrB [1921, 1921]      *
  [148]     chrB [1941, 1941]      *
  [149]     chrB [1961, 1961]      *
  [150]     chrB [1981, 1981]      *
  ---
  seqlengths:
   chrA chrB
   1000 2000
> 
> checkcount(2000, c(chrA=1000, chrB=2000), spacing=50)
GRanges with 60 ranges and 0 metadata columns:
       seqnames       ranges strand
          <Rle>    <IRanges>  <Rle>
   [1]     chrA   [  1,   1]      *
   [2]     chrA   [ 51,  51]      *
   [3]     chrA   [101, 101]      *
   [4]     chrA   [151, 151]      *
   [5]     chrA   [201, 201]      *
   ...      ...          ...    ...
  [56]     chrB [1751, 1751]      *
  [57]     chrB [1801, 1801]      *
  [58]     chrB [1851, 1851]      *
  [59]     chrB [1901, 1901]      *
  [60]     chrB [1951, 1951]      *
  ---
  seqlengths:
   chrA chrB
   1000 2000
> 
> checkcount(5000, c(chrA=1000, chrB=2000), spacing=25)
GRanges with 120 ranges and 0 metadata columns:
        seqnames       ranges strand
           <Rle>    <IRanges>  <Rle>
    [1]     chrA   [  1,   1]      *
    [2]     chrA   [ 26,  26]      *
    [3]     chrA   [ 51,  51]      *
    [4]     chrA   [ 76,  76]      *
    [5]     chrA   [101, 101]      *
    ...      ...          ...    ...
  [116]     chrB [1876, 1876]      *
  [117]     chrB [1901, 1901]      *
  [118]     chrB [1926, 1926]      *
  [119]     chrB [1951, 1951]      *
  [120]     chrB [1976, 1976]      *
  ---
  seqlengths:
   chrA chrB
   1000 2000
> 
> checkcount(5000, c(chrA=1000, chrB=2000), spacing=25, max.frag=100)
GRanges with 120 ranges and 0 metadata columns:
        seqnames       ranges strand
           <Rle>    <IRanges>  <Rle>
    [1]     chrA   [  1,   1]      *
    [2]     chrA   [ 26,  26]      *
    [3]     chrA   [ 51,  51]      *
    [4]     chrA   [ 76,  76]      *
    [5]     chrA   [101, 101]      *
    ...      ...          ...    ...
  [116]     chrB [1876, 1876]      *
  [117]     chrB [1901, 1901]      *
  [118]     chrB [1926, 1926]      *
  [119]     chrB [1951, 1951]      *
  [120]     chrB [1976, 1976]      *
  ---
  seqlengths:
   chrA chrB
   1000 2000
> 
> # Checking out restrictions on the max size.
> 
> checkcount(1000, c(chrA=1000, chrB=2000), spacing=50, right=0)
GRanges with 60 ranges and 0 metadata columns:
       seqnames       ranges strand
          <Rle>    <IRanges>  <Rle>
   [1]     chrA   [  1,   1]      *
   [2]     chrA   [ 51,  51]      *
   [3]     chrA   [101, 101]      *
   [4]     chrA   [151, 151]      *
   [5]     chrA   [201, 201]      *
   ...      ...          ...    ...
  [56]     chrB [1751, 1751]      *
  [57]     chrB [1801, 1801]      *
  [58]     chrB [1851, 1851]      *
  [59]     chrB [1901, 1901]      *
  [60]     chrB [1951, 1951]      *
  ---
  seqlengths:
   chrA chrB
   1000 2000
> 
> checkcount(1000, c(chrA=1000, chrB=2000), spacing=100, right=20)
GRanges with 30 ranges and 0 metadata columns:
       seqnames       ranges strand
          <Rle>    <IRanges>  <Rle>
   [1]     chrA   [  1,  21]      *
   [2]     chrA   [101, 121]      *
   [3]     chrA   [201, 221]      *
   [4]     chrA   [301, 321]      *
   [5]     chrA   [401, 421]      *
   ...      ...          ...    ...
  [26]     chrB [1501, 1521]      *
  [27]     chrB [1601, 1621]      *
  [28]     chrB [1701, 1721]      *
  [29]     chrB [1801, 1821]      *
  [30]     chrB [1901, 1921]      *
  ---
  seqlengths:
   chrA chrB
   1000 2000
> 
> checkcount(2000, c(chrA=1000, chrB=2000), spacing=100, right=10, max.frag=200)
GRanges with 30 ranges and 0 metadata columns:
       seqnames       ranges strand
          <Rle>    <IRanges>  <Rle>
   [1]     chrA   [  1,  11]      *
   [2]     chrA   [101, 111]      *
   [3]     chrA   [201, 211]      *
   [4]     chrA   [301, 311]      *
   [5]     chrA   [401, 411]      *
   ...      ...          ...    ...
  [26]     chrB [1501, 1511]      *
  [27]     chrB [1601, 1611]      *
  [28]     chrB [1701, 1711]      *
  [29]     chrB [1801, 1811]      *
  [30]     chrB [1901, 1911]      *
  ---
  seqlengths:
   chrA chrB
   1000 2000
> 
> # Checking out window extension details.
> 
> checkcount(1000, c(chrA=1000, chrB=2000), spacing=30, right=100)
GRanges with 101 ranges and 0 metadata columns:
        seqnames       ranges strand
           <Rle>    <IRanges>  <Rle>
    [1]     chrA   [  1, 101]      *
    [2]     chrA   [ 31, 131]      *
    [3]     chrA   [ 61, 161]      *
    [4]     chrA   [ 91, 191]      *
    [5]     chrA   [121, 221]      *
    ...      ...          ...    ...
   [97]     chrB [1861, 1961]      *
   [98]     chrB [1891, 1991]      *
   [99]     chrB [1921, 2000]      *
  [100]     chrB [1951, 2000]      *
  [101]     chrB [1981, 2000]      *
  ---
  seqlengths:
   chrA chrB
   1000 2000
> 
> checkcount(1000, c(chrA=1000, chrB=2000), spacing=20, left=100)
GRanges with 150 ranges and 0 metadata columns:
        seqnames       ranges strand
           <Rle>    <IRanges>  <Rle>
    [1]     chrA      [1,  1]      *
    [2]     chrA      [1, 21]      *
    [3]     chrA      [1, 41]      *
    [4]     chrA      [1, 61]      *
    [5]     chrA      [1, 81]      *
    ...      ...          ...    ...
  [146]     chrB [1801, 1901]      *
  [147]     chrB [1821, 1921]      *
  [148]     chrB [1841, 1941]      *
  [149]     chrB [1861, 1961]      *
  [150]     chrB [1881, 1981]      *
  ---
  seqlengths:
   chrA chrB
   1000 2000
> 
> checkcount(2000, c(chrA=1000, chrB=2000), spacing=15, right=20, left=20)
GRanges with 201 ranges and 0 metadata columns:
        seqnames       ranges strand
           <Rle>    <IRanges>  <Rle>
    [1]     chrA     [ 1, 21]      *
    [2]     chrA     [ 1, 36]      *
    [3]     chrA     [11, 51]      *
    [4]     chrA     [26, 66]      *
    [5]     chrA     [41, 81]      *
    ...      ...          ...    ...
  [197]     chrB [1916, 1956]      *
  [198]     chrB [1931, 1971]      *
  [199]     chrB [1946, 1986]      *
  [200]     chrB [1961, 2000]      *
  [201]     chrB [1976, 2000]      *
  ---
  seqlengths:
   chrA chrB
   1000 2000
> 
> checkcount(2000, c(chrA=1000, chrB=2000), spacing=15, right=10, left=10, max.frag=200)
GRanges with 201 ranges and 0 metadata columns:
        seqnames       ranges strand
           <Rle>    <IRanges>  <Rle>
    [1]     chrA     [ 1, 11]      *
    [2]     chrA     [ 6, 26]      *
    [3]     chrA     [21, 41]      *
    [4]     chrA     [36, 56]      *
    [5]     chrA     [51, 71]      *
    ...      ...          ...    ...
  [197]     chrB [1926, 1946]      *
  [198]     chrB [1941, 1961]      *
  [199]     chrB [1956, 1976]      *
  [200]     chrB [1971, 1991]      *
  [201]     chrB [1986, 2000]      *
  ---
  seqlengths:
   chrA chrB
   1000 2000
> 	
> # Checking out read extension for singles.
> 
> checkcount(1000, c(chrA=1000, chrB=2000), spacing=20, ext=100)
GRanges with 150 ranges and 0 metadata columns:
        seqnames       ranges strand
           <Rle>    <IRanges>  <Rle>
    [1]     chrA     [ 1,  1]      *
    [2]     chrA     [21, 21]      *
    [3]     chrA     [41, 41]      *
    [4]     chrA     [61, 61]      *
    [5]     chrA     [81, 81]      *
    ...      ...          ...    ...
  [146]     chrB [1901, 1901]      *
  [147]     chrB [1921, 1921]      *
  [148]     chrB [1941, 1941]      *
  [149]     chrB [1961, 1961]      *
  [150]     chrB [1981, 1981]      *
  ---
  seqlengths:
   chrA chrB
   1000 2000
> 
> checkcount(2000, c(chrA=1000, chrB=2000), spacing=50, ext=50)
GRanges with 60 ranges and 0 metadata columns:
       seqnames       ranges strand
          <Rle>    <IRanges>  <Rle>
   [1]     chrA   [  1,   1]      *
   [2]     chrA   [ 51,  51]      *
   [3]     chrA   [101, 101]      *
   [4]     chrA   [151, 151]      *
   [5]     chrA   [201, 201]      *
   ...      ...          ...    ...
  [56]     chrB [1751, 1751]      *
  [57]     chrB [1801, 1801]      *
  [58]     chrB [1851, 1851]      *
  [59]     chrB [1901, 1901]      *
  [60]     chrB [1951, 1951]      *
  ---
  seqlengths:
   chrA chrB
   1000 2000
> 
> checkcount(5000, c(chrA=1000, chrB=2000), spacing=25, ext=20)
GRanges with 120 ranges and 0 metadata columns:
        seqnames       ranges strand
           <Rle>    <IRanges>  <Rle>
    [1]     chrA   [  1,   1]      *
    [2]     chrA   [ 26,  26]      *
    [3]     chrA   [ 51,  51]      *
    [4]     chrA   [ 76,  76]      *
    [5]     chrA   [101, 101]      *
    ...      ...          ...    ...
  [116]     chrB [1876, 1876]      *
  [117]     chrB [1901, 1901]      *
  [118]     chrB [1926, 1926]      *
  [119]     chrB [1951, 1951]      *
  [120]     chrB [1976, 1976]      *
  ---
  seqlengths:
   chrA chrB
   1000 2000
> 
> checkcount(5000, c(chrA=1000, chrB=2000), spacing=25, ext=200)
GRanges with 120 ranges and 0 metadata columns:
        seqnames       ranges strand
           <Rle>    <IRanges>  <Rle>
    [1]     chrA   [  1,   1]      *
    [2]     chrA   [ 26,  26]      *
    [3]     chrA   [ 51,  51]      *
    [4]     chrA   [ 76,  76]      *
    [5]     chrA   [101, 101]      *
    ...      ...          ...    ...
  [116]     chrB [1876, 1876]      *
  [117]     chrB [1901, 1901]      *
  [118]     chrB [1926, 1926]      *
  [119]     chrB [1951, 1951]      *
  [120]     chrB [1976, 1976]      *
  ---
  seqlengths:
   chrA chrB
   1000 2000
> 	
> ###################################################################################################
> # Cleaning up.
> 
> unlink(dir, recursive=TRUE);
> 
> ###################################################################################################
> # End.
> 
> 
> 
> proc.time()
   user  system elapsed 
 22.196   0.174  22.412 
