\name{consolidateSizes}
\alias{consolidateSizes}

\title{Consolidate window sizes}
\description{Consolidate DB results from multiple window sizes.}

\usage{
consolidateSizes(data.list, result.list, equiweight=TRUE,  merge.args=list(tol=1000), 
    combine.args=list(), region=NULL, overlap.args=list()) 
}

\arguments{
\item{data.list}{a list of \code{RangedSummarizedExperiment} objects, produced by \code{\link{windowCounts}}}
\item{result.list}{a list of data frames containing the DB test results for each entry of \code{data.list}}
\item{equiweight}{a logical scalar indicating whether equal weighting from each window size should be enforced}
\item{merge.args}{a list of parameters to pass to \code{\link{mergeWindows}} when \code{FUN=NULL}}
\item{combine.args}{a list of parameters to pass to \code{\link{combineTests}}}
\item{region}{a \code{GRanges} object specifying regions of interest for overlapping with windows}
\item{overlap.args}{a list of parameters to pass to \code{\link{findOverlaps}}}
}

\value{
A list is returned, containing:
\item{id}{a list of integer vectors, where each vector corresponds to an object in \code{data.list}; the entries of the vector specify the cluster to which each row of that object is assigned}
\item{region}{a \code{GRanges} object containing the genomic coordinates of the clusters of merged windows (or other regions, if \code{region} is specified)}
\item{table}{a data frame containing the combined DB results for each \code{region}}	
}

\details{
This function consolidates DB results from multiple window sizes, to provide comprehensive detection of DB at a range of spatial resolutions.
\code{RangedSummarizedExperiment} objects can be generated by running \code{\link{windowCounts}} at a range of window sizes.
Windows of all sizes are clustered together through \code{\link{mergeWindows}}, and the p-values from all windows in each cluster are combined using \code{\link{combineTests}}.

Some effort is required to equalize the contribution of each window size to the combined p-value of each cluster.
This is done by setting \code{equiweight=TRUE}, where the weight of each window is inversely proportional to the number of windows of that size.
Otherwise, the combined p-value would be determined by numerous small windows in each cluster.

If \code{region} is specified, each entry of \code{region} is defined as a cluster.
Windows in each cluster are identified using \code{\link{findOverlaps}}, and consolidation is performed across multiple window sizes like before.
Note that the returned \code{id} will be a list of \code{\link{Hits}} objects rather than integer vectors, as one window (subject) may overlap more than one region (query).
}

\seealso{
\code{\link{windowCounts}},
\code{\link{mergeWindows}},
\code{\link{findOverlaps}},
\code{\link{combineTests}}
}

\author{
Aaron Lun
}

\examples{
bamFiles <- system.file("exdata", c("rep1.bam", "rep2.bam"), package="csaw")
low <- windowCounts(bamFiles, width=1, filter=1)
med <- windowCounts(bamFiles, width=100, filter=1)
high <- windowCounts(bamFiles, width=500, filter=1)

# Making up some DB results.
dbl <- data.frame(logFC=rnorm(nrow(low)), PValue=runif(nrow(low)), logCPM=0)
dbm <- data.frame(logFC=rnorm(nrow(med)), PValue=runif(nrow(med)), logCPM=0)
dbh <- data.frame(logFC=rnorm(nrow(high)), PValue=runif(nrow(high)), logCPM=0)

# Consolidating.
cons <- consolidateSizes(list(low, med, high), list(dbl, dbm, dbh),
	merge.args=list(tol=100, max.width=300))
cons$region
cons$id
cons$table

# Without weights.
cons <- consolidateSizes(list(low, med, high), list(dbl, dbm, dbh),
	merge.args=list(tol=100, max.width=300), equiweight=FALSE)
cons$table

# Trying with a custom region.
of.interest <- GRanges(c('chrA', 'chrA', 'chrB', 'chrC'), 
    IRanges(c(1, 500, 100, 1000), c(200, 1000, 700, 1500)))
cons <- consolidateSizes(list(low, med, high), list(dbl, dbm, dbh),
    region=of.interest)
cons$table
cons$id

# Trying with limited numbers of overlaps; empty regions are ignored.
cons <- consolidateSizes(list(low[1,], med[1,], high[1,]), 
    list(dbl[1,], dbm[1,], dbh[1,]), region=of.interest)
cons$region
cons$table
}

\keyword{clustering}
