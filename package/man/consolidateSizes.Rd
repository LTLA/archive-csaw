\name{consolidateSizes}
\alias{consolidateSizes}

\title{Consolidate window sizes}
\description{Consolidate DB results from multiple window sizes.}

\usage{
consolidateSizes(data.list, result.list, equiweight=TRUE,
    merge.args=list(tol=1000), combine.args=list(), region) 
}

\arguments{
\item{data.list}{a list of \code{SummarizedExperiment} objects, produced by \code{\link{windowCounts}}; or, a list of integer vectors (see details)}
\item{result.list}{a list of data frames containing the DB test results for each entry of \code{data.list}}
\item{equiweight}{a logical scalar indicating whether equal weighting from each window size should be enforced}
\item{merge.args}{a list of parameters to pass to \code{\link{mergeWindows}} when \code{FUN=NULL}}
\item{combine.args}{a list of parameters to pass to \code{\link{combineTests}}}
\item{region}{a \code{GRanges} object to supply when \code{data.list} is a list of integer vectors}
}

\value{
A list is returned, containing:
\item{id}{a list of integer vectors, where each vector corresponds to an object in \code{data.list}; the entries of the vector specify the cluster to which each row of that object is assigned}
\item{region}{a \code{GRanges} object containing the genomic coordinates of the clusters of merged windows (or other regions, depending on \code{FUN})}
\item{table}{a data frame containing the combined DB results for each \code{region}}	
}

\details{
This function consolidates DB results from multiple window sizes, to provide comprehensive detection of DB at a range of spatial resolutions.
\code{SummarizedExperiment} objects can be generated by running \code{\link{windowCounts}} at a range of window sizes.
Windows of all sizes are clustered together through \code{\link{mergeWindows}}, and the p-values from all windows in each cluster are combined using \code{\link{combineTests}}.

Some effort is required to equalize the contribution of each window size to the combined p-value of each cluster.
This is done by setting \code{equiweight=TRUE}, where the weight of each window is inversely proportional to the number of windows of that size.
Otherwise, the combined p-value would be determined by numerous small windows in each cluster.

Other forms of clustering can be performed outside of \code{consolidateSizes}, and the cluster IDs can be supplied as a list of integer vectors in \code{data.list}.
Each vector should correspond to a window size, and each entry of that vector should specifies the cluster to which the corresponding window belongs.
This format is equivalent to the returned \code{id} list.
Coordinates must be supplied separately in \code{region}, or will be set to \code{NA} if nothing is specified.
}

\seealso{
\code{\link{windowCounts}},
\code{\link{mergeWindows}},
\code{\link{combineTests}}
}

\author{
Aaron Lun
}

\examples{
bamFiles <- system.file("exdata", c("rep1.bam", "rep2.bam"), package="csaw")
low <- windowCounts(bamFiles, width=1, filter=1)
med <- windowCounts(bamFiles, width=100, filter=1)
high <- windowCounts(bamFiles, width=500, filter=1)

# Making up some DB results.
dbl <- data.frame(logFC=rnorm(nrow(low)), PValue=runif(nrow(low)), logCPM=0)
dbm <- data.frame(logFC=rnorm(nrow(med)), PValue=runif(nrow(med)), logCPM=0)
dbh <- data.frame(logFC=rnorm(nrow(high)), PValue=runif(nrow(high)), logCPM=0)

# Consolidating.
cons <- consolidateSizes(list(low, med, high), list(dbl, dbm, dbh),
	merge.args=list(tol=100, max.width=300))
cons$region
cons$id
cons$table

# Trying with a custom function.
of.interest <- GRanges(c('chrA', 'chrA', 'chrB', 'chrC'), 
    IRanges(c(1, 500, 100, 1000), c(200, 1000, 700, 1500)))
llap <- findOverlaps(rowRanges(low), of.interest)
mlap <- findOverlaps(rowRanges(med), of.interest)
hlap <- findOverlaps(rowRanges(high), of.interest)
cons <- consolidateSizes(list(subjectHits(llap), subjectHits(mlap), subjectHits(hlap)), 
    list(dbl[queryHits(llap),], dbm[queryHits(mlap),], dbh[queryHits(hlap),]),
    region=of.interest)
cons$table
}

\keyword{clustering}
